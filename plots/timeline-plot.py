#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# sched-plot -- Plot a workload schedule
#
# Given a system configuration, a workload description, and a schedule as
# generated by `scorsa-sched', this program generates a plot displaying the
# amount of sockets used by each job over time, as well as submission times
# for each job in the workload.
#
# Copyright Â© 2018 Aaron Call <aaron.callo@bsc.es>

import logging
import argparse
import json
import itertools
import re

import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from matplotlib.ticker import AutoMinorLocator
from random import sample
from utils import square_plot

def workloads_exec_time_add_value(workload_list, name, job, gpus_list, start_time, end_time, submitted_time):
    if name not in workload_list:
        workload_list[name] = dict()
    if job not in workload_list[name]:
        workload_list[name][job] = dict()
        exec_time = end_time - start_time
        exec_time_submitted = end_time - submitted_time

        workload_list[name][job]['gpus'] = gpus_list
        workload_list[name][job]['start_time'] = start_time
        workload_list[name][job]['end_time'] = end_time
        workload_list[name][job]['submitted_time'] = submitted_time
        workload_list[name][job]['exec_time'] = exec_time
        workload_list[name][job]['exec_time_submitted'] = exec_time_submitted
    return workload_list


def get_fig_index():
    return itertools.cycle(['(c)', '(d)', '(b)', '(a)', '(e)', '(f)', '(g)', '(h)'])

def get_colors():
    return itertools.cycle(['k', 'g', 'b', 'm', 'y', 'c'])

def get_lines_format():
    return itertools.cycle(["--", "-.", ":", "-"])

def get_colors2():
    return itertools.cycle(['#f2b1bc', '#02e0bd', '#7cc8f0', '#9083de', '#07a998', '#5a71ff', '#224fc2', '#19f2fb',
                            '#8e9e1f', '#3266c8', '#2b2c08', '#975ce0', '#e1c295', '#95e4c9', '#5d160e', '#4b5241',
                            '#7a55f8', '#ac3320', '#58aa2d', '#953164'])
def get_pattern():
    return itertools.cycle(['-', '+', 'x', '\\', 'o', 'O', '.'])

colors = get_colors()
patterns = get_pattern()

logging.basicConfig(format="%(message)s", level=logging.ERROR)

ap = argparse.ArgumentParser()
#ap.add_argument("-l", "--layout", dest="l", required=True,
#                help="Layout ile (json format)")
ap.add_argument("-s", "--schedule", dest="s", required=True,
				help="JSON schedule file")
ap.add_argument("-l", "--layout", dest="l", required=True,
                help="JSON layout file")
args = ap.parse_args()

with open(args.s) as s:
	schedule = json.load(s)
with open(args.l) as l:
    layout = json.load(l)

numResources=0
resourcesRacks = {}
ytickslabels = [0]
for key,value in layout.items():
    id = int(re.findall(r'\d+', key)[-1])
    resourcesRacks[id] = {}
    for p in range(0,len(layout[key]["nvmes"])):
        resourcesRacks[id][p] = numResources
        numResources=numResources+1

    for p in value["nvmes"]:
        label=str(p["bandwidth"])+","+str(p["capacity"])
        #if label not in ytickslabels:
        ytickslabels.append(label)

colorsList = {}
patternsList = {}
for n in range(0,len(schedule)):
    colorsList[n] = colors.next()
    patternsList[n] = patterns.next()

lastTime = sorted(schedule, key=lambda k: k['completion'])[-1]["completion"]
schedule = sorted(schedule, key=lambda k: k['step'], reverse=False)

completions = {}
p1, axs = plt.subplots(1,1)
axs.set_xlim([0,lastTime+20])

# axs.set_xlim([0,lastTime+2])
axs.set_ylim([0,numResources])

for job in schedule:
    color = colorsList[job["jobid"][-1]]
    pattern = patternsList[job["jobid"][-1]]
    if job["completion"] > job["deadline"][-1]:
        color = 'red'
        pattern = '*'
    axs = square_plot.add_job_square(axs, job["jobid"], job, pattern, color, resourcesRacks)
    axs = square_plot.add_text(axs, job["completion"], -0.3, job["completion"], 10)

axs = square_plot.add_text(axs, 0, -0.3, 0, 10)

axs.xaxis.set_major_locator(matplotlib.ticker.MultipleLocator(48))
axs.yaxis.set_major_locator(matplotlib.ticker.MultipleLocator(1))
axs.yaxis.set_minor_locator(AutoMinorLocator(2))
axs.grid(b=True, which='major', color='w', linewidth=1.0)
# axs.grid(b=True, which='minor', color='w', linewidth=0.3)

axs.set_ylabel('NVMe (Bandwidth MB/s, Capacity MB)', fontsize=15)
axs.tick_params(labelsize=15)
# axs.legend(loc='upper right', ncol=1,  fancybox=True, shadow=True,
#               prop={'size': 15}, labelspacing=0.1, handlelength=0.6, columnspacing=0.05,
#               handleheight=0.6, borderpad=0.05,
#               bbox_to_anchor=(1.01, 1.16))

_ = [tick.label.set_fontsize(20) for tick in axs.xaxis.get_major_ticks()]
axs.set_xticklabels([])
axs.set_yticklabels(ytickslabels,verticalalignment='bottom')
plt.xlabel("Execution time (s)")
plt.title("NVMe used for job allocation over time")
# plt.xticks(range(0,lastTime),rotation=90)
#plt.yticks(np.arange(len(schedule)))
# plt.yticks(np.arange(11))
# plt.ylabel("NVMe used")
plt.tight_layout()
plt.savefig('plots/timeline-allocation.pdf', bbox_inches='tight')
plt.clf()

